<!DOCTYPE html><html lang="zh-CN"><head><meta name="baidu-site-verification" content="WJEAqh4Drc" /><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="jverson's blog | java | web | Jverson"><title>Java8 中的 Streams API.md | 墨言</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.1"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java8 中的 Streams API.md</h1><a id="logo" href="/.">墨言</a><p class="description">LIFE IS SIMPLE, LOVE SMILE AND CODE</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="http://album.jverson.com/"><i class="fa fa-picture-o"> 相册</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java8 中的 Streams API.md</h1><div class="post-meta">Mar 23, 2018<span> | </span><span class="category"><a href="/categories/Coding/">Coding</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2018/03/23/java8-stream-api/" href="/2018/03/23/java8-stream-api/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>Stream 作为 Java8 的一大亮点，是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（过滤、排序、分组、聚合等），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。<a id="more"></a></p>
<p>同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。借助 Stream API 和 Lambda，开发人员可以很容易的编写出高性能的并发处理程序。</p>
<h2 id="Why-Stream-API"><a href="#Why-Stream-API" class="headerlink" title="Why Stream API"></a>Why Stream API</h2><p>Stream 提供的功能都可以在集合类中实现，为什么还要定义全新的Stream API？Oracle官方给出了几个重要原因：</p>
<ul>
<li><p>集合类持有的所有元素都是存储在内存中的，非常巨大的集合类会占用大量的内存，而Stream的元素却是在访问的时候才被计算出来，这种“延迟计算”的特性有点类似Clojure的lazy-seq，占用内存很少。</p>
</li>
<li><p>集合类的迭代逻辑是调用者负责，通常是for循环，而Stream的迭代是隐含在对Stream的各种操作中，例如map()。</p>
</li>
</ul>
<p>如何理解第一条提到的<code>延迟计算</code>？下面看一个例子。</p>
<p>如果要表示自然数集合，显然用集合类是不可能实现的，因为自然数有无穷多个。但是Stream可以做到。自然数集合的规则非常简单，每个元素都是前一个元素的值+1，因此，自然数发生器用代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaturalSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> value = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.value = value + <span class="number">1</span>;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反复调用get()，将得到一个无穷数列，利用这个Supplier，可以创建一个无穷的Stream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Stream&lt;Long&gt; natural = Stream.generate(<span class="keyword">new</span> NaturalSupplier()); <span class="comment">//generate的入参是一个supplier接口的实现</span></div><div class="line">	natural.map(x -&gt; x*x).limit(<span class="number">10</span>).forEach(System.out::println);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果利用集合想得到1到10的平方，需要先创建一个1到10的 list，这个 list 是在内存中的，如果这个集合特别大则特别占用内存，但是如果利用 Stream 则只有在引用的时候才会去计算。</p>
<p>同时利用 Stream API，可以设计更加简单的数据接口。例如，生成斐波那契数列，完全可以用一个无穷流表示。可以就看到用 Stream 表示 Fibonacci 数列，其接口比任何其他接口定义都要来得简单灵活并且高效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibonacciSupplier</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> b = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> x = a + b;</div><div class="line">        a = b;</div><div class="line">        b = x;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciStream</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Stream&lt;Long&gt; fibonacci = Stream.generate(<span class="keyword">new</span> FibonacciSupplier());</div><div class="line">        fibonacci.limit(<span class="number">10</span>).forEach(System.out::println);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><p>创建流的方式有很多，最常用的有：集合类转换为流、通过数组创建流、通过文件创建流以及通过函数创建流，示例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//集合-&gt;流</span></div><div class="line">Sets.newHashSet().stream();</div><div class="line">Lists.newArrayList().stream();	</div><div class="line"></div><div class="line"><span class="comment">// 数组-&gt;流</span></div><div class="line">String[] strs = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>&#125;;</div><div class="line">Stream&lt;String&gt; stream = Arrays.stream(strs);</div><div class="line"></div><div class="line"><span class="comment">// 文件-&gt;流</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	Stream&lt;String&gt; fileStream = Files.lines(Paths.get(<span class="string">"d://a.txt"</span>), Charsets.UTF_8);</div><div class="line">	List&lt;String&gt; lines = fileStream.filter(s -&gt; s!=<span class="keyword">null</span> &amp;&amp; s.startsWith(<span class="string">"K_"</span>)).collect(Collectors.toList());</div><div class="line">	System.out.println(lines);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数创建流</span></div><div class="line"><span class="comment">// 1. iteartor  接受Function参数，0 为seed，n -&gt; n + 2 为 Function 接口的抽象方法 R apply(T t) 的实现； 从0开始打印51个偶数</span></div><div class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">51</span>).forEach(System.out::println);  </div><div class="line"><span class="comment">// 2. generate  接受Supplier参数，() -&gt; "Hello Man!" 为 Supplier接口的抽象方法 T get()的实现; 重复打印10个"Hello Man!"</span></div><div class="line">Stream.generate(() -&gt; <span class="string">"Hello Man!"</span>).limit(<span class="number">10</span>).forEach(System.out::println);</div></pre></td></tr></table></figure>
<h2 id="使用流（中间处理-intermediate）"><a href="#使用流（中间处理-intermediate）" class="headerlink" title="使用流（中间处理 intermediate）"></a>使用流（中间处理 intermediate）</h2><p>一个流可以后面跟随零个或多个 intermediate 操作，Stream API 中常用的流操作有以下这些：</p>
<ul>
<li>filter()：对流的元素过滤</li>
<li>map()：将流的元素映射成另一个类型</li>
<li>distinct()：去除流中重复的元素</li>
<li>sorted()：对流的元素排序</li>
<li>forEach()：对流中的每个元素执行某个操作</li>
<li>peek()：与forEach()方法效果类似，不同的是，该方法会返回一个新的流，而forEach()无返回</li>
<li>limit()：截取流中前面几个元素</li>
<li>skip()：跳过流中前面几个元素</li>
<li>toArray()：将流转换为数组</li>
<li>reduce()：对流中的元素归约操作，将每个元素合起来形成一个新的值</li>
<li>collect()：对流的汇总操作，比如输出成List集合</li>
<li>anyMatch()：匹配流中的元素，类似的操作还有allMatch()和noneMatch()方法</li>
<li>findFirst()：查找第一个元素，类似的还有findAny()方法</li>
<li>max()：求最大值</li>
<li>min()：求最小值</li>
<li>count()：求总数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 去重</span></div><div class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"d"</span>, <span class="keyword">null</span>, <span class="string">"a"</span>, <span class="string">"c"</span>, <span class="string">"f"</span>, <span class="string">"a"</span>, <span class="string">"x"</span>, <span class="string">"n"</span>);</div><div class="line">strings.stream().filter(s -&gt; s!=<span class="keyword">null</span>).distinct().forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// 筛选(对流的元素过滤)</span></div><div class="line">apples.stream().filter(apple -&gt; apple.getWeight()&gt;<span class="number">2</span>).forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// 排序(对流的元素排序)</span></div><div class="line">apples.stream().sorted((Apple a, Apple b) -&gt; Float.valueOf(a.getWeight()).compareTo(b.getWeight())).forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// 映射(将流的元素映射成另一个类型), 将实体Apple列表映射为其属性产地的列表</span></div><div class="line">List&lt;String&gt; origins = apples.stream().map(apple -&gt; apple.getOrigin()).collect(Collectors.toList());</div><div class="line"></div><div class="line"><span class="comment">// 查找和匹配(将流的元素映射成另一个类型)</span></div><div class="line">System.out.println(<span class="string">"-------查找任意元素匹配------"</span>);</div><div class="line">System.out.println(apples.stream().anyMatch(apple -&gt; apple.getWeight()&gt;<span class="number">2</span> &amp;&amp; apple.getOrigin().equals(<span class="string">"baoji"</span>)));</div><div class="line">System.out.println(<span class="string">"-------查找所有元素匹配------"</span>);</div><div class="line">System.out.println(apples.stream().allMatch(apple -&gt; apple.getWeight()&gt;<span class="number">2</span>));</div><div class="line">System.out.println(<span class="string">"-------查找任意元素没有匹配------"</span>);</div><div class="line">System.out.println(apples.stream().noneMatch(apple -&gt; apple.getWeight()&gt;<span class="number">2</span>));</div><div class="line">System.out.println(<span class="string">"-------查找元素------"</span>);</div><div class="line">System.out.println(apples.stream().filter(apple -&gt; apple.getWeight()&gt;<span class="number">2</span>).count());</div><div class="line">System.out.println(apples.stream().filter(apple -&gt; apple.getWeight()&gt;<span class="number">2</span>).findFirst()); <span class="comment">//返回满足条件第一个元素</span></div><div class="line">System.out.println(apples.stream().filter(apple -&gt; apple.getWeight()&gt;<span class="number">2</span>).findAny()); <span class="comment">//返回满足条件任一元素，返回也是第一个元素，效率考虑推荐使用findAny</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*归约操作（求和，求最大值或最小值）*/</span></div><div class="line">System.out.println(<span class="string">"-------求和，计算所有苹果总重------"</span>);</div><div class="line">System.out.println(apples.stream().map(Apple::getWeight).reduce((n,m) -&gt; n+m).get()); <span class="comment">//reduce操作接收BinaryOperator类型参数，它继承了BiFunction，接受两个类型相同的参数</span></div><div class="line"><span class="comment">//T reduce(T identity, BinaryOperator accumulator)</span></div><div class="line"><span class="keyword">int</span> value = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">100</span>, (sum, item) -&gt; sum + item); <span class="comment">//110, 100即为计算初始值，每次相加计算值都会传递到下一次计算的第一个参数。</span></div><div class="line"><span class="comment">//最大最小值</span></div><div class="line">apples.stream().max(Comparator.comparing(Apple::getWeight)).get();</div><div class="line">apples.stream().min(Comparator.comparing(Apple::getWeight)).get();</div></pre></td></tr></table></figure>
<h2 id="数据收集（终端处理t-erminal）"><a href="#数据收集（终端处理t-erminal）" class="headerlink" title="数据收集（终端处理t erminal）"></a>数据收集（终端处理t erminal）</h2><p>前面两部分内容分别为流式数据处理的前两个步骤：从数据源创建流、使用流进行中间处理。数据收集是流式数据处理的终端处理，与中间处理不同的是，一个流只能有一个 terminal 操作，终端处理会消耗流，也就是说，终端处理之后，这个流就会被关闭，如果再进行中间处理，就会抛出异常。数据收集主要使用 collect 方法，该方法也属于归约操作。</p>
<p>Collectors工具类为我们提供了用于汇总的方法，包括summarizingInt()，summarizingLong()和summarizingDouble()，该方法会返回一个DoubleSummaryStatistics对象，包含一系列归约操作的方法，如：汇总、计算平均数、最大值、最小值、计算总数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DoubleSummaryStatistics dss = apples.stream().collect(summarizingDouble(Apple::getWeight));</div><div class="line"><span class="keyword">double</span> sum = dss.getSum();          <span class="comment">// 汇总</span></div><div class="line"><span class="keyword">double</span> average = dss.getAverage();  <span class="comment">// 求平均数</span></div><div class="line"><span class="keyword">long</span> count = dss.getCount();        <span class="comment">// 计算总数</span></div><div class="line"><span class="keyword">double</span> max = dss.getMax();          <span class="comment">// 最大值</span></div><div class="line"><span class="keyword">double</span> min = dss.getMin();</div></pre></td></tr></table></figure>
<p><strong>分组</strong><br>和关系数据库一样，流也提供了类似于数据库中GROUP BY分组的特性，由 Collectors.groupingBy() 方法提供。使用可以参考下面示例，分组方法 groupingBy() 接收一个 Function 接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 苹果按照产地分组，打印产自陕西的分组</span></div><div class="line">Map&lt;String, List&lt;Apple&gt;&gt; originGroup = apples.stream().collect(groupingBy(Apple::getOrigin));</div><div class="line">System.out.println(originGroup.get(<span class="string">"shanxi"</span>));</div></pre></td></tr></table></figure>
<p>当遇到更为复杂的情况时，可以直接使用Lambda表达式来表示这个分组逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 苹果按照重量区间分组，打印大号的分组</span></div><div class="line">Map&lt;String, List&lt;Apple&gt;&gt; weightGroup = apples.stream().collect(groupingBy(apple -&gt; &#123;</div><div class="line">	<span class="keyword">if</span> (apple.getWeight()&lt;<span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"small"</span>;</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (apple.getWeight()&lt;<span class="number">2</span> &amp;&amp; apple.getWeight()&gt;<span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"medium"</span>;</div><div class="line">	&#125;<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"big"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;)); </div><div class="line">System.out.println(weightGroup.get(<span class="string">"big"</span>));</div></pre></td></tr></table></figure>
<h2 id="流转换为其它数据结构"><a href="#流转换为其它数据结构" class="headerlink" title="流转换为其它数据结构"></a>流转换为其它数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 1. Array</div><div class="line">String[] strArray1 = stream.toArray(String[]::new);</div><div class="line">// 2. Collection</div><div class="line">List&lt;String&gt; list1 = stream.collect(Collectors.toList());</div><div class="line">List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));</div><div class="line">Set set1 = stream.collect(Collectors.toSet());</div><div class="line">Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));</div><div class="line">// 3. String</div><div class="line">String str = stream.collect(Collectors.joining()).toString();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，Stream 的特性可以归纳为：</p>
<ul>
<li>不是数据结构</li>
<li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li>
<li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>所有 Stream 的操作必须以 lambda 表达式为参数</li>
<li>不支持索引访问</li>
<li>很容易生成数组或者 List</li>
<li>惰性化</li>
<li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li>
<li>Intermediate 操作永远是惰性化的。</li>
<li>并行能力</li>
<li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的</li>
<li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="external"><strong>Java 8 中的 Streams API 详解</strong></a></li>
<li><a href="https://www.liaoxuefeng.com/article/001411309538536a1455df20d284b81a7bfa2f91db0f223000" target="_blank" rel="external">Java 8新特性：全新的Stream API</a></li>
<li><a href="https://lw900925.github.io/java/java8-stream-api.html" target="_blank" rel="external">Java 8新特性（二）：Stream API</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.1" async></script><a data-url="http://jverson.com/2018/03/23/java8-stream-api/" data-id="cjiqrmdpb0036h3fymakq2sbc" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java8/">Java8</a></div><div class="post-nav"><a href="/2018/03/08/https-certificate/" class="pre">记录一次 Https 握手故障的排查</a><a href="/2018/05/21/add-https-to-blog/" class="next">博客域名升级 Https</a></div><div id="disqus_thread"><script>var disqus_shortname = 'jverson';
var disqus_identifier = '2018/03/23/java8-stream-api/';
var disqus_title = 'Java8 中的 Streams API.md';
var disqus_url = 'http://jverson.com/2018/03/23/java8-stream-api/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//jverson.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><a href="https://jverson.com/"><img src="https://github.com/jiwenxing/hexo-blog/blob/master/themes/maupassant/source/img/201610131152_383.jpg?raw=true" alt="" border="0" style="margin-top:15px; border-radius: 300px;" width="180px"; height="180px"; ></a></div><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jverson.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a><span class="category-list-count">23</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Coding-Thinking/">Coding Thinking</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thinking/">Thinking</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Travelling/">Travelling</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Concurrent/" style="font-size: 15px;">Concurrent</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/Cache/" style="font-size: 15px;">Cache</a> <a href="/tags/Https/" style="font-size: 15px;">Https</a> <a href="/tags/AutoHotkey/" style="font-size: 15px;">AutoHotkey</a> <a href="/tags/Alfred-Markdown/" style="font-size: 15px;">Alfred Markdown</a> <a href="/tags/Blog/" style="font-size: 15px;">Blog</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Frontend/" style="font-size: 15px;">Frontend</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Travelling/" style="font-size: 15px;">Travelling</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Summary/" style="font-size: 15px;">Summary</a> <a href="/tags/Memory/" style="font-size: 15px;">Memory</a> <a href="/tags/Cookie/" style="font-size: 15px;">Cookie</a> <a href="/tags/Session/" style="font-size: 15px;">Session</a> <a href="/tags/Http/" style="font-size: 15px;">Http</a> <a href="/tags/Basic/" style="font-size: 15px;">Basic</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-bar-chart"> 访客统计</i></div><a href="https://s05.flagcounter.com/more/quj"><img src="https://s05.flagcounter.com/count2/quj/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" alt="Since 2016.04.28" border="0" style="margin-top:15px;"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">墨言.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" href="https://jverson.com"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.1" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.1"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.1"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.1"></script></div></body></html>